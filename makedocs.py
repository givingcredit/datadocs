import pandas as pd
import os, shutil
from jinja2 import Environment, PackageLoader
import yaml
import os.path
import json
import markdown

class FieldError(Exception):
    """
    Class to inform the user of a field error in her or
    his yaml configuration.
    """
    def __init__(self, section, field):
        self.section = section
        self.field = field
        self.value = "%s field in the %s section (is the %s field missing?)" % (self.field, self.section, self.field)
    def __str__(self):
        return repr(self.field)

class Section():
    """

    Args:
        title (String)               Section title
        description (String)         Description
    """
    def __init__(self, name, title = None, description = None):
        self.title = title
        self.description = description
        self.tables = []

    def addTable(self, table):
        """
        Add a table object to the table list.
        Args:
            table (Table)    Table object
        """
        self.tables.append(table)

    def getFieldNames(self):
        """
        Returns a list of field names in this section
        """
        fieldNames = []
        for table in self.tables:
            for field in table.fields:
                fieldNames.append(field.name)
        return fieldNames

    def getHtmlName(self, appendText=None):
        """
        Returns a string taking the file name and turning it into a
        reasonable html file name that strips white space and .csv

        Args:
            appendText      String optional text to append to the end of the
                            html file name.
        """
        htmlName = self.title.replace(' ', '_').lower()
        htmlName = htmlName.replace('.csv', '')
        if appendText:
            htmlName += "_" + appendText
        htmlName += '.html'
        return htmlName

    def addUncategorizedFields(self, df):
        """
        Adds all fields that have not been documented by the user
        to a table called "Uncategorized" and add the
        table to this section.

        Args:
            df    Pandas dataframe.
        """

        # create an uncategorized table
        uncategorized = Table("Uncategorized", "Autogenerated list of fields that have not been documented.")
        documentedFieldNames = self.getFieldNames()

        for fieldName in list(df.columns.values):
            if fieldName not in documentedFieldNames:
                # this field name is not documented, so
                # let's add it to the list of uncategorized
                # fields
                field = Field(fieldName)
                field.dataType = field.getDataType(df)

                # add the field to the table
                uncategorized.addField(field)

        # add the table
        self.addTable(uncategorized)

    def printSelectAll(self, language = "R"):
        """
        Prints code in the specified language that selects all fields
        in this section.

        Args:
            language    String indicating the language to select all variables in.
        """
        code = ""
        if language.lower() == "r":

            # TODO: fix last comma issue

            code += "c(\n"

            for table in self.tables:
                code += "   # %s\n" % table.title

                for field in table.fields:
                    code += '   "%s",\n' % field.name
            code += ")"
        elif language.lower() == "python":

            code += "[\n"
            for table in self.tables:
                code += "   # %s\n" % table.title

                for field in table.fields:
                    code += '   "%s",\n' % field.name
            code += "]"

        return code

    def countFields(self):
        """
        Counts the number of fields in this section.
        """

        fieldCount = 0
        for table in self.tables:
            fieldCount += len(table.fields)
        return fieldCount


class Table():
    """
    A table holds any number of fields in a section
    """
    def __init__(self, title, name, description = None):
        """
        Args:
            title           Friendly table title
            name            Name of the table in the database
            description     String description
        """
        self.title = title
        self.name = name
        self.description = description
        self.fields = []

    def addField(self, field):
        self.fields.append(field)

class Field():
    """
    A field in a section.
    """
    def __init__(self, name, description=None, private=False, transformed=False, percentNotNA=None):
        """
        Args:
            name            String field name in the section
            description     String field description
            private         Boolean indicating if a field is private or public
            transformed     Boolean indicating if a field is raw (False) or has gone
                            through some transformation process (True).
            percentNotNA    Numeric field indicating percentage of observations not NA
        """
        self.name = name
        self.description = description
        self.percentNotNA = percentNotNA
        self.dataType = None
        self.private = private
        self.transformed = transformed

    def getDataType(self, df):
        """
        Guesses the datatype of the field of a dataframe.
        Args:
            df              Pandas dataframe this field is in
        Return:
            Returns a string guessing the field's data type.
        """

        # the datatype map maps pandas data types to user friendly types
        dataTypeMap = {
            "object" : "Text",
            "int64" : "Numeric",
            "float64" : "Numeric",
            "bool" : "Boolean",
            "date" : "Date",
            "categorical" : "Categorical"
        }

        # set the data type
        dataType = dataTypeMap[str(df[self.name].dtype)]

        # look for special cases where we guess a different datatype
        if "date" in fieldName.lower():
            dataType = dataTypeMap["date"]
        # check if a text datatype is actually categorical
        elif dataType == "Text":
            # if there are fewer than k unique answers, then guess it's categorical
            numberOfUniqueAnswers = len(df[self.name].value_counts())
            if numberOfUniqueAnswers < 20: # TODO: This is kind of a hack, might think of a better solution
                  dataType = dataTypeMap["categorical"]

        return dataType

def generateSearch(sections):
    """
    Generates a JSON file that allows users to search fields across sections.

    Args:
        sections    A list of section objects.
    Return:
        Returns a JSON file that is a list of dictionaries, where
        each dictionary defines a field.
    """

    search = []

    for section in sections:
        tableNumber = 1
        for table in section.tables:
            fieldNumber = 1
            for field in table.fields:
                search.append({
                    "field" : field.name,
                    "description": field.description,
                    "table" : table.title,
                    "section" : section.title,
                    "field_link" : "%s#field-%d-%d" % (section.getHtmlName(), tableNumber, fieldNumber),
                    "table_link" : "%s#table-%d" % (section.getHtmlName(), tableNumber),
                    "section_link" : "%s" % (section.getHtmlName())
                })
                fieldNumber += 1
            tableNumber += 1

    # return as json
    return json.dumps(search)

if __name__ == "__main__":
    """
    Loop through every section in the datadocs yaml
    file.
    """

    # remove the /docs dir if it exists
    if os.path.exists("site"):
        shutil.rmtree('site')
    # if docs doesn't exist, which it shouldn't, make it again
    if not os.path.exists('site'):
        os.makedirs('site')

    # get the data docs settings
    datadocs = yaml.load(open("docs/datadocs.yaml", "r"), Loader=yaml.Loader)
    showUncategorized = datadocs['show_uncategorized']
    showPrivate = datadocs['show_private']

    # instantiate a list of sections
    sections = []
    for selected_section in datadocs['sections']:
        # get the section name from the datadocs file
        section_name = selected_section['name']

        # open the section yaml
        selected_section = yaml.load(open("docs/" + section_name + ".yaml", "r"), Loader=yaml.Loader)

        section_title = selected_section['title']
        section_description = selected_section['description']

        # create a section object
        section = Section(section_name, section_title, section_description)
        # read the data set as a csv and convert to a data frame
        #df = pd.read_csv("docs/" + sectionFileName, sep=',', header=0, encoding='ISO-8859-1', index_col=None)

        for selected_table in selected_section['tables']:
            table_title = selected_table['title']
            table_name = selected_table['name']
            table_description = None
            if 'description' in selected_table:
                table_description = selected_table['description']
            # create a table object
            table = Table(table_title, table_name, table_description)
            if 'fields' in selected_table:
                for selectedField in selected_table['fields']:
                    fieldName = selectedField['name']
                    fieldDescription = selectedField['description']
                    fieldIsPrivate = False
                    if 'private' in selectedField:
                        fieldIsPrivate = selectedField['private']
                    fieldIsTransformed = False
                    if 'transformed' in selectedField:
                        fieldIsTransformed = selectedField['transformed']

                    # create a field object only if the field is not private or the
                    # field is private and the settings indiate we want to display
                    # private fields.
                    if showPrivate == True or (showPrivate == False and fieldIsPrivate == False):
                        field = Field(fieldName, description=fieldDescription, private=fieldIsPrivate, transformed=fieldIsTransformed)
                        #if "type" not in selectedField:
                            # the user has not documented a datatype, so let's
                            # guess what the data type is.
                        #    field.dataType = field.getDataType(df)
                        #else:
                            # Documentation includes a data type, so use that instead
                        #field.dataType = selectedField['type']

                        # add this field to the table
                        table.addField(field)

            # add this table to the section
            section.addTable(table)

        # add this section to the list of sections
        sections.append(section)

        # determine if we want to add uncategorized field
        #if showUncategorized:
        #    section.addUncategorizedFields(df)

    # generate search index
    search = generateSearch(sections)

    """
    Render templates
    """
    # jinja2 templating settings
    env = Environment(loader=PackageLoader('makedocs', 'templates'))

    # make index page
    template = env.get_template('home.html')
    file = open('site/index.html', 'w')

    # documentation properties
    docTitle = None
    docDescription = None
    if datadocs['title']:
        docTitle = datadocs['title']

    # check if there is an index.md file in /docs. If there is
    # open it up, convert the markdown contents and pass it along as
    # content
    try:
        content = markdown.markdown(open('docs/index.md', 'r').read())
    except:
        content = None
    file.write(template.render(sections=sections, static="static", home="index.html", docTitle=docTitle,
        search=search, content=content))

    for section in sections:
        template = env.get_template('section.html')
        file = open('site/%s' % (section.getHtmlName()), 'w')

        # check if there is an [file_name].md file in /docs. If there is
        # open it up, convert the markdown contents and pass it along as
        # content
        try:
            content = markdown.markdown(open('docs/' + section.name + '.md', 'r').read())
        except:
            content = None

        file.write(template.render(section=section, sections=sections, static="static", home="index.html",
            docTitle=docTitle,
            showUncategorized=showUncategorized, search=search, content=content))

    # copy static folder (css and images)
    shutil.copytree("static", "site/static")
